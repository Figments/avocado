# Avocado, the strongly-typed MongoDB driver

[![Avocado on crates.io](https://img.shields.io/crates/v/avocado.svg)](https://crates.io/crates/avocado)
[![Avocado on docs.rs](https://docs.rs/avocado/badge.svg)](https://docs.rs/avocado)
[![Avocado Download](https://img.shields.io/crates/d/avocado.svg)](https://crates.io/crates/avocado)
[![Avocado License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/H2CO3/avocado/blob/master/LICENSE.txt)
[![Lines of Code](https://tokei.rs/b1/github/H2CO3/avocado)](https://github.com/Aaronepower/tokei)
[![Twitter](https://img.shields.io/badge/twitter-@H2CO3_iOS-blue.svg?style=flat&colorB=64A5DE&label=Twitter)](http://twitter.com/H2CO3_iOS)

[![goto counter](https://img.shields.io/github/search/H2CO3/avocado/goto.svg)](https://github.com/H2CO3/avocado/search?q=goto)
[![unsafe counter](https://img.shields.io/github/search/H2CO3/avocado/unsafe.svg)](https://github.com/H2CO3/avocado/search?q=unsafe)
[![fuck counter](https://img.shields.io/github/search/H2CO3/avocado/fuck.svg)](https://github.com/H2CO3/avocado/search?q=fuck)

## Usage

* See the [online documentation](https://docs.rs/avocado) above, or open it locally:
* `cargo doc --features schema_validation --open`
* Check out the [`examples/`](https://github.com/H2CO3/avocado/blob/master/examples/) folder
* The `schema_validation` feature can be enabled, in which case the `DatabaseExt::empty_collection()` method becomes available. If a collection is created using this method, it will add a JSON schema validation pass and specify the schema as generated by [`magnet`](https://github.com/H2CO3/magnet).

    **This can potentially be slow if you are performing many insertions into a collection of a complex type. However, it dynamically ensures that other users/drivers can't put malformed data in the collection.** Therefore it's probably more useful if you or somebody else are accessing a database from outside the Avocado driver too. It's also great for debugging Avocado itself.

## TODO:

* Add a section to the documentation comparing Avocado and Wither. Advantages of using Avocado:
	* More type-safe and more flexible
		* Uses a parametric UID type instead of a raw `ObjectId`, so incorrect code like `user.id == department.id` doesn't compile
		* The underlying raw type of UIDs can be changed to anything that implements `Eq` and is (de)serializable; there's built-in support for `ObjectId` (of course) and `Uuid`.
		* Provides useful literal types for lesser dynamic typing and more expressive code when creating raw BSON literals (e.g. `Order`, `IndexType`, etc.)
	* The API is incremental.
		* If all you want is to insert some entities and executie simple queries on them, it's possible to use raw BSON `Document`s. Methods on `Collection` don't even take an "options" argument because sensible defaults are provided, so you don't have to write `None` or `Default::default()` all the time for what is basically a dummy argument.
		* If however you want to perform more complex manipulations or change the default reading/writing options, then the `Query`, `Pipeline`, `Update`, etc. traits can be implemented and customized manually, in great detail.
	* Designed with performance in mind.
		* Supports `Cursor`s, which doesn't require collecting all results in a `Vec`. Useful for incremental retrieval of large result sets.
	* More convenient and natural index syntax in `#[derive(Doc)]` for:
		* Compound indices
		* Embedded document fields
	* Encourages writing clean, well-organized code
		* Documents are grouped into collections, closely mirroring the MongoDB model. You don't have to pass the entire DB handle around (and clone it every time). This aids interface segregation and the principle of least privilege, as it's possible to create "repositories" based on individual types: they only depend on some collections, and they don't need to have access to the entire database.
		* The collections are the "active" part; documents are treated as naive value types for all purposes, so we're not trying to mimic the "active record pattern" â€” since that is basically impossible to do 100% correctly.
* Upload this along with some introduction to [https://h2co3.github.io/avocado/](https://h2co3.github.io/avocado/); add links to crates.io and docs.rs as well
* In `tests/ops.rs`, in macro `implement_tests!`, use the `?` Kleene operator around the return type of test functions, once it's stabilized (in Rust 1.32)
* Auto-derive `Doc` trait
	* Add `Doc::id(&self) -> Option<&Uid<Self>>` and `Doc::set_id(&mut self, id: Into<Uid<Self>>)` methods
		* `derive` them (return or assign the field that serializes under the key `"_id"`)
		* Use them in `Collection` methods, and **document these methods in detail**:
			* `insert_one()` (if `id` is `None`, generate one and set it)
			* `insert_many()` (ditto)
			* `upsert_entity()` (if an entity was inserted, set the returned id on the in-memory entity)
	* Check existence of first segment of index key paths (?)
* Add `find_one_and_replace()`, `find_one_and_update()`, `find_one_and_upsert()`, `find_one_and_delete()` methods to `Collection`
* **More tests!**
	* Modified behavior of `insert_one()`, `insert_many()`, and `upsert_entity()`
	* Newly-added `Collection::find_one_and_*()` methods
	* Compiletest-rs: check that the `#[derive]` macro detects certain kinds of errors at compilation time
* Add `weights` property to text indices
* Add migrations
* Default `Doc::Id` to `ObjectId` and `Query::Output` to `T`, once [#29661](https://github.com/rust-lang/rust/issues/29661) is stabilized
* Make `Error` more structured, e.g. introduce an `ErrorKind` to match on, and a method for transitively retrieving it (throughout the cause chain)
